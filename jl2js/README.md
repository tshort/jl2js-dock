# Very Experimental and Quite Broken!

Only the simplest compiled code works.

# Conversion of Julia to JavaScript 

Build the docker container:

```
docker build -t jl2js .
```

Convert a Julia file to JavaScript:

```
./jl2js.sh example "['_myabs','_myfun']"
```

The first argument, `example`, is the file to be compiled to JavaScript with no extension. The second argument is a list of the functions you want available. 

Right now, you have to also include the internal functions for each of these as follows:

```
./jl2js.sh example "['_myabs','_julia_myabs_2473','_myfun','_julia_myfun_2533']"
```

You can test a JavaScript file with node. Here is an example:

```
a = require('./example.js')
a._julia_myabs_2473(-11.1)
```

# What works

* Basic math involving immutables (like Tuples and StaticArrays)

* Arrays with a bit of kludgey work. The garbage collection needs to be initialized and turned off on the JavaScript side, like:

```js
a = require('./example.js')
a._jl_gc_init()
a._jl_gc_enable(0)
```

# What's broken

**Most everything**, including at least:

* IO

* Anything eval'd or dynamically generated at runtime (everything's static)

* Anything that uses compiled code (anything ccall'd)

Note that even some basic math calls out to compiled code. 

# Known problems

## Emscripten can't find Julia functions

In the Emscripten invocation, you need something like `-s EXPORTED_FUNCTIONS="['_myabs']"` to indicate which functions you need access to on the JavaScript side. 
It doesn't work, though. We need to `-s EXPORTED_FUNCTIONS="['_myabs','_julia_myabs_2533']"`. 
(The 2533 can change depending on the input order.)
The first entry convinces Emscripten we need the function, but it can't find it later, so both invocations are needed. This is likely an Emscripten issue, not a Julia issue.

## Emscripten can't run functions called with `ccall`

`ccall` functions don't work, even if they are compiled to LLVM bitcode and linked in with Emscripten. One can work around this by manually editing the generated JavaScript file. For example, to allocate and use vectors, the `_jlplt_jl_alloc_array_1d_47` in the following line needs to be changed to `_jl_alloc_array_1d`. 

```js
var FUNCTION_TABLE_iii = [b13,b13,b13,b13,b13,b13,_jlplt_jl_alloc_array_1d_47,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,_realloc,_calloc,b13,b13,b13,b13,b13
```

Another ramification of this is that Emscripten may leave out functions (like  `_jl_alloc_array_1d`) because it doesn't know that they are needed. They can be manually added back in by adding the function to the list of Emscripten `EXPORTED_FUNCTIONS`.

This likely needs work on the Julia side to convert `ccall`s to direct calls.

# Notes

* `libjulia.bc` and `libuv.bc` are generated by Dockerfiles elsewhere in this repo. Both of these have fairly complete coverage. `libuv` is missing some critical parts for IO. `libjulia` stuff seems to work well given the limitations above.

* The version of Julia in this Dockerfile is a 32-bit version with threading turned off. Threading needed to be removed to get rid of some junk at the top of many generated functions. The 32-bit version is used to get the LLVM bitcode closer to what Emscripten is looking for.

* WebAssembly should be easy once JavaScript is working better.

* There are many more libraries like BLAS that could be compiled and linked in.

# Background

This Dockerfile is based on the work Alex Mellnik (@amellnik) started [here](https://discourse.julialang.org/t/current-status-of-julia-to-js-via-emscripten/5530).

Rust has the best JavaScript/WebAssembly support of the LLVM-based systems beyond C/C++. 
